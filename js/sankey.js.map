{"version":3,"sources":["sankey.js"],"names":["d3","sankey","nodeWidth","nodePadding","size","computeLinkDepths","link","forEach","node","sy","dy","sourceLinks","targetLinks","ty","center","value","_","arguments","length","nodes","links","layout","iterations","computeNodeDepths","source","target","push","Math","max","sum","nextNodes","remainingNodes","dx","indexOf","moveSinksRight","x","moveSourcesRight","kx","computeNodeLinks","nodesByBreadth","nest","entries","d","map","values","ky","min","i","y","initializeNodeDepth","resolveCollisions","relaxRightToLeft","alpha","weightedTarget","reverse","relaxLeftToRight","weightedSource","y0","n","computeNodeValues","computeNodeBreadths","relayout","curvature","x0","x1","xi","x2","x3","interpolateNumber","y1"],"mappings":"aAAAA,GAAGC,OAAS,WACR,IAAIA,EAAS,GADdA,EAAS,GACJA,EAAJ,EACIC,EAAS,CAAA,EAAG,GACZC,EAAAA,GACAC,EAAO,GAkQf,SAAAC,IAIUC,EAAIC,QAAJ,SAAAC,GACAC,IAAEA,EAAIH,EAAKI,EAAX,EAFFF,EAAAG,YAAAJ,QAAA,SAAAD,GAIIA,EAACM,GAAAA,EACHN,GAAAA,EAAAI,KADFF,EAAAI,YAAAL,QAAA,SAAAD,GANFA,EAAAO,GAAAA,EAQIA,GAAMP,EAAKI,OAajB,SAASI,EAAON,GAIhB,OAASO,EAAMT,EAAfE,EAAqBE,GAAA,EAArB,SAASK,EAAMT,GAIf,OAAOL,EAAPc,MAAA,OAnSAd,EAKSC,UALT,SAAAc,GAQE,OAAKC,UAAUC,QADjBjB,GAAAe,EACOC,GAAyBf,GADhCD,EAAAE,YAAA,SAAAa,GAOE,OAAKC,UAAUC,QADjBjB,GAAAe,EACOC,GAAyBd,GADhCF,EAAAkB,MAAA,SAAAH,GAOE,OAAKC,UAAUC,QADjBjB,EAAAe,EACOC,GAAyBE,GADhClB,EAAAmB,MAAA,SAAAJ,GAOE,OAAKC,UAAUC,QADjBjB,EAAAe,EACOC,GAAyBG,GADhCnB,EAAAG,KAAA,SAAAY,GAOE,OAAKC,UAAUC,QADjBjB,EAAAe,EACOC,GAAyBb,GADhCH,EAAAoB,OAAA,SAAAC,GAUEC,OAwCEf,EAAKG,QAAAA,SAALH,GACAA,EAAKI,YAAL,GAFFJ,EAAAI,YAAA,KAKEQ,EAAII,QAASlB,SAAKkB,GAAlB,IACIC,EAASnB,EAAKmB,OACdA,EAAOD,EAAPC,OACkB,iBAAXA,IAAqBA,EAASnB,EAAKmB,OAASN,EAAMb,EAAKmB,SAC1CnB,iBAAjBK,IAAPc,EAAAnB,EAAAmB,OAAAN,EAAAb,EAAAmB,SACAA,EAAOb,YAAYc,KAAKpB,GAN1BmB,EAAAb,YAAAc,KAAApB,KAaEE,EAAKO,QAAQY,SACX3B,GAFJQ,EAAAO,MAAAY,KAAAC,IAQF5B,GAAA6B,IAAArB,EAAAG,YAAAI,GACAf,GAAA6B,IAAArB,EAAAI,YAAAG,MAGA,WAKE,IACEe,EADFC,EAAsBb,EAEpBa,EAAAA,EAEEvB,KAAKwB,EAALd,QACAV,EAAKG,GACHoB,EAAaxB,QAAT,SAAuBkB,GACzBK,EAAAA,EAAAA,EACDtB,EAAAwB,GAAA9B,EAHHM,EAAAG,YAAAJ,QAAA,SAAAD,GAHFwB,EAAAG,QAAA3B,EAAAmB,QAAA,GASAM,EAAiBD,KAAAA,EAAjBL,YAAAM,EAAiBD,IAKnBI,GAcE,SAAsBhB,GACpBV,EAAID,QAAM,SAAVC,GACDA,EAAAG,YAAAO,SAHHV,EAAA2B,EAAAA,EAAA,MATFD,CAASE,GAkBL5B,SAAA6B,GADFlB,EAAAZ,QAAA,SAAAC,GAGDA,EAAA2B,GAAAE,IAnBClB,EAAcf,EAASI,GAAMN,IAAAiC,EAAA,IAhG7BG,GAuHuB,SAAAhB,GADF,IAEjBiB,EAAAvC,GAAAwC,OACCC,IAAQtB,SACJuB,GAAA,OAAAA,EAAYP,IAErBM,QAAAtB,GAFKwB,IAAI,SAASD,GAAK,OAAOA,EAAEE,UAa9B,WACE,IAAAC,EAAQzC,GAAI0C,IAAJP,EAAW,SAAoBpC,GADzC,OAAAC,EAAA,IAAAe,EAAAD,OAAA,GAAAf,GAAAH,GAAA6B,IAAAV,EAAAJ,KAMIP,EAAAD,QAAA,SAAAY,GACAX,EAAKE,QAAS,SAASmC,EAAvBE,GAFFvC,EAAAwC,EAAAD,EADFvC,EAAAE,GAAAF,EAAAO,MAAA8B,MAUDzB,EAAAb,QAAA,SAAAD,GAFGA,EAAKI,GAAKJ,EAAKS,MAAQ8B,KAtB3BI,GAEAC,IACEC,IAAAA,IAAAA,EAAiBC,EAAjB,EAAiBA,IAAjB9B,GAyCI,SAAqBJ,GAU1B,SAAAmC,EAAA/C,GAFG,OAAOQ,EAAOR,EAAKmB,QAAUnB,EAAKS,MAP9BwB,EAAWV,QAAQyB,UAAC3C,QAAa0C,SAAAA,GACjC7C,EAAID,QAAQ,SAASC,GACtB,IAJHwC,EAIGxC,EAAAG,YAAAO,SAJH8B,EAAAhD,GAAA6B,IAAArB,EAAAG,YAAA0C,GAAArD,GAAA6B,IAAArB,EAAAG,YAAAI,GADFP,EAAAwC,IAAAA,EAAAlC,EAAAN,IAAA4C,OAtCAF,CAAiBE,GAAA,KACjBG,IAwBI,SAAqBrC,GAU1B,SAAAsC,EAAAlD,GAFG,OAAOQ,EAAOR,EAAKkB,QAAUlB,EAAKS,MAP9BwB,EAAWV,QAAQ,SAACjB,EAAa4C,GACjChD,EAAID,QAAQ,SAASC,GACtB,IAJHwC,EAIGxC,EAAAI,YAAAM,SAJH8B,EAAAhD,GAAA6B,IAAArB,EAAAI,YAAA4C,GAAAxD,GAAA6B,IAAArB,EAAAI,YAAAG,GADFP,EAAAwC,IAAAA,EAAAlC,EAAAN,IAAA4C,OArBAF,CAAiBE,GAClBF,IAmDG,SAAAA,IAAAX,EAAAhC,QAAA,SAAAY,GAYEsC,IAZF,IAGKjD,EAJgCE,EAQrC+C,EAAA,EAJIC,EAAIvC,EAAMD,OASPV,EAAI,EAAJuC,EAASvC,IAATuC,EADI,GADTrC,EAAK+C,GAKPjD,EAAAW,EAAA4B,IALiBC,KACHxC,EAAKwC,GAAKtC,GAKtB+C,EAAKjD,EAAGL,EAAAA,EAALO,GAAuBP,EAK1B,GAASuD,GALXhD,EAAK+C,EAAKtD,EAAcC,EAAK,IASzBqD,IAHAjD,EAAIA,EAAGW,GAAPT,EAGKF,EAAIkD,EAAT,EAAA,GAAAX,IAAAA,EA1BN,GA4BGrC,GADEF,EAAAW,EAAA4B,IACFC,EAAAxC,EAAAE,GAAAP,EAAAsD,KA5BHjD,EAAAwC,GAAAtC,GA8BD+C,EAAAjD,EAAAwC,KAnNDW,CAAiBrC,GACjBsC,IACArC,GAJFtB,EAAA4D,SAAA,WASA5D,OACEI,IADKwD,GAAP5D,EAAAK,KAAA,WAME,IAAIwD,EAAY,GAAhB,SAAIA,EAAYpB,GAGd,IAAIqB,EAAKrB,EAAElB,OAAOW,EAAIO,EAAElB,OAAOQ,GADjCgC,EAAAtB,EAAAjB,OAAiBU,EACT8B,EAAKzC,GAAAA,kBAAoBQ,EAA/BgC,GACME,EAAKzC,EAAAA,GACL0C,EAAKF,EAACG,EAAAA,GACNX,EAAKf,EAACoB,OAAAA,EAHZpB,EAAAjC,GAAAiC,EAAAhC,GAAA,EAIM2D,EAAK3B,EAACjB,OAAIqC,EAAAA,EAJhBjD,GAAA6B,EAAAhC,GAAA,EAAA,MAKSgC,IAAElB,EAAF,IAAAiC,EACAf,IAAEjB,EAAF,IAAAgC,EACF,IAAAU,EAAW,IAAXE,EAIR,IAAAL,EAAA,IAAAK,EAWH,OARI/D,EAAKW,UAAUC,SAAQF,GACvB8C,OAAAA,UAAA5C,QACA4C,GAAA9C,EAHFV,GAEEwD,GAOJxD,GAsNOL","file":"sankey.js","sourcesContent":["d3.sankey = function() {\n    var sankey = {},\n        nodeWidth = 24,\n        nodePadding = 8,\n        size = [1, 1],\n        nodes = [],\n        links = [];\n  \n    sankey.nodeWidth = function(_) {\n      if (!arguments.length) return nodeWidth;\n      nodeWidth = +_;\n      return sankey;\n    };\n  \n    sankey.nodePadding = function(_) {\n      if (!arguments.length) return nodePadding;\n      nodePadding = +_;\n      return sankey;\n    };\n  \n    sankey.nodes = function(_) {\n      if (!arguments.length) return nodes;\n      nodes = _;\n      return sankey;\n    };\n  \n    sankey.links = function(_) {\n      if (!arguments.length) return links;\n      links = _;\n      return sankey;\n    };\n  \n    sankey.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return sankey;\n    };\n  \n    sankey.layout = function(iterations) {\n      computeNodeLinks();\n      computeNodeValues();\n      computeNodeBreadths();\n      computeNodeDepths(iterations);\n      computeLinkDepths();\n      return sankey;\n    };\n  \n    sankey.relayout = function() {\n      computeLinkDepths();\n      return sankey;\n    };\n  \n    sankey.link = function() {\n      var curvature = .5;\n  \n      function link(d) {\n        var x0 = d.source.x + d.source.dx,\n            x1 = d.target.x,\n            xi = d3.interpolateNumber(x0, x1),\n            x2 = xi(curvature),\n            x3 = xi(1 - curvature),\n            y0 = d.source.y + d.sy + d.dy / 2,\n            y1 = d.target.y + d.ty + d.dy / 2;\n        return \"M\" + x0 + \",\" + y0\n             + \"C\" + x2 + \",\" + y0\n             + \" \" + x3 + \",\" + y1\n             + \" \" + x1 + \",\" + y1;\n      }\n  \n      link.curvature = function(_) {\n        if (!arguments.length) return curvature;\n        curvature = +_;\n        return link;\n      };\n  \n      return link;\n    };\n  \n    // Populate the sourceLinks and targetLinks for each node.\n    // Also, if the source and target are not objects, assume they are indices.\n    function computeNodeLinks() {\n      nodes.forEach(function(node) {\n        node.sourceLinks = [];\n        node.targetLinks = [];\n      });\n      links.forEach(function(link) {\n        var source = link.source,\n            target = link.target;\n        if (typeof source === \"number\") source = link.source = nodes[link.source];\n        if (typeof target === \"number\") target = link.target = nodes[link.target];\n        source.sourceLinks.push(link);\n        target.targetLinks.push(link);\n      });\n    }\n  \n    // Compute the value (size) of each node by summing the associated links.\n    function computeNodeValues() {\n      nodes.forEach(function(node) {\n        node.value = Math.max(\n          d3.sum(node.sourceLinks, value),\n          d3.sum(node.targetLinks, value)\n        );\n      });\n    }\n  \n    // Iteratively assign the breadth (x-position) for each node.\n    // Nodes are assigned the maximum breadth of incoming neighbors plus one;\n    // nodes with no incoming links are assigned breadth zero, while\n    // nodes with no outgoing links are assigned the maximum breadth.\n    function computeNodeBreadths() {\n      var remainingNodes = nodes,\n          nextNodes,\n          x = 0;\n  \n      while (remainingNodes.length) {\n        nextNodes = [];\n        remainingNodes.forEach(function(node) {\n          node.x = x;\n          node.dx = nodeWidth;\n          node.sourceLinks.forEach(function(link) {\n            if (nextNodes.indexOf(link.target) < 0) {\n              nextNodes.push(link.target);\n            }\n          });\n        });\n        remainingNodes = nextNodes;\n        ++x;\n      }\n  \n      //\n      moveSinksRight(x);\n      scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));\n    }\n  \n    function moveSourcesRight() {\n      nodes.forEach(function(node) {\n        if (!node.targetLinks.length) {\n          node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;\n        }\n      });\n    }\n  \n    function moveSinksRight(x) {\n      nodes.forEach(function(node) {\n        if (!node.sourceLinks.length) {\n          node.x = x - 1;\n        }\n      });\n    }\n  \n    function scaleNodeBreadths(kx) {\n      nodes.forEach(function(node) {\n        node.x *= kx;\n      });\n    }\n  \n    function computeNodeDepths(iterations) {\n      var nodesByBreadth = d3.nest()\n          .key(function(d) { return d.x; })\n          //.sortKeys(d3.ascending)\n          .entries(nodes)\n          .map(function(d) { return d.values; });\n  \n      //\n      initializeNodeDepth();\n      resolveCollisions();\n      for (var alpha = 1; iterations > 0; --iterations) {\n        relaxRightToLeft(alpha *= .99);\n        resolveCollisions();\n        relaxLeftToRight(alpha);\n        resolveCollisions();\n      }\n  \n      function initializeNodeDepth() {\n        var ky = d3.min(nodesByBreadth, function(nodes) {\n          return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);\n        });\n  \n        nodesByBreadth.forEach(function(nodes) {\n          nodes.forEach(function(node, i) {\n            node.y = i;\n            node.dy = node.value * ky;\n          });\n        });\n  \n        links.forEach(function(link) {\n          link.dy = link.value * ky;\n        });\n      }\n  \n      function relaxLeftToRight(alpha) {\n        nodesByBreadth.forEach(function(nodes, breadth) {\n          nodes.forEach(function(node) {\n            if (node.targetLinks.length) {\n              var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);\n              node.y += (y - center(node)) * alpha;\n            }\n          });\n        });\n  \n        function weightedSource(link) {\n          return center(link.source) * link.value;\n        }\n      }\n  \n      function relaxRightToLeft(alpha) {\n        nodesByBreadth.slice().reverse().forEach(function(nodes) {\n          nodes.forEach(function(node) {\n            if (node.sourceLinks.length) {\n              var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);\n              node.y += (y - center(node)) * alpha;\n            }\n          });\n        });\n  \n        function weightedTarget(link) {\n          return center(link.target) * link.value;\n        }\n      }\n  \n      function resolveCollisions() {\n        nodesByBreadth.forEach(function(nodes) {\n          var node,\n              dy,\n              y0 = 0,\n              n = nodes.length,\n              i;\n  \n          // Push any overlapping nodes down.\n          //nodes.sort(ascendingDepth);\n          for (i = 0; i < n; ++i) {\n            node = nodes[i];\n            dy = y0 - node.y;\n            if (dy > 0) node.y += dy;\n            y0 = node.y + node.dy + nodePadding;\n          }\n  \n          // If the bottommost node goes outside the bounds, push it back up.\n          dy = y0 - nodePadding - size[1];\n          if (dy > 0) {\n            y0 = node.y -= dy;\n  \n            // Push any overlapping nodes back up.\n            for (i = n - 2; i >= 0; --i) {\n              node = nodes[i];\n              dy = node.y + node.dy + nodePadding - y0;\n              if (dy > 0) node.y -= dy;\n              y0 = node.y;\n            }\n          }\n        });\n      }\n  \n      function ascendingDepth(a, b) {\n        return a.y - b.y;\n      }\n    }\n  \n    function computeLinkDepths() {\n      /* nodes.forEach(function(node) {\n        node.sourceLinks.sort(ascendingTargetDepth);\n        node.targetLinks.sort(ascendingSourceDepth);\n      }); */\n      nodes.forEach(function(node) {\n        var sy = 0, ty = 0;\n        node.sourceLinks.forEach(function(link) {\n          link.sy = sy;\n          sy += link.dy;\n        });\n        node.targetLinks.forEach(function(link) {\n          link.ty = ty;\n          ty += link.dy;\n        });\n      });\n  \n      function ascendingSourceDepth(a, b) {\n        return a.source.y - b.source.y;\n      }\n  \n      function ascendingTargetDepth(a, b) {\n        return a.target.y - b.target.y;\n      }\n    }\n  \n    function center(node) {\n      return node.y + node.dy / 2;\n    }\n  \n    function value(link) {\n      return link.value;\n    }\n  \n    return sankey;\n  };"]}